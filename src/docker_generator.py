"""
Docker Configuration Generator
"""
from ast_nodes import Program, Service, Endpoint
from typing import Dict, List


class DockerGenerator:
    """Generates Dockerfile and docker-compose.yml"""
    
    def generate_dockerfile(self, service: Service) -> str:
        """Generate Dockerfile for a service"""
        port = service.configs.get('port', 8080)
        
        dockerfile = f"""# Dockerfile for {service.name}
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE {port}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:{port}/health || exit 1

# Run the application
CMD ["python", "app.py"]
"""
        return dockerfile
    
    def generate_docker_compose(self, program: Program) -> str:
        """Generate docker-compose.yml for all services"""
        compose = """version: '3.8'

services:
"""
        
        for service in program.services:
            port = service.configs.get('port', 8080)
            replicas = service.configs.get('replicas', 1)
            
            service_config = f"""
  {service.name.lower()}:
    build:
      context: ./{service.name.lower()}
      dockerfile: Dockerfile
    ports:
      - "{port}:{port}"
    environment:
      - SERVICE_NAME={service.name}
      - PORT={port}
"""
            
            # Add database if configured
            if 'database' in service.configs:
                db_config = service.configs['database']
                db_type = db_config.get('type', 'postgres')
                compose += service_config
                compose += f"""    depends_on:
      - {service.name.lower()}_db
"""
                
                # Add database service
                if db_type == 'postgres':
                    compose += f"""
  {service.name.lower()}_db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB={service.name.lower()}_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - {service.name.lower()}_db_data:/var/lib/postgresql/data
"""
            else:
                compose += service_config
            
            # Add deploy configuration for replicas
            if replicas > 1:
                compose += f"""    deploy:
      replicas: {replicas}
      restart_policy:
        condition: on-failure
"""
            compose += "\n"
        
        # Add volumes section if needed
        compose += "\nvolumes:\n"
        for service in program.services:
            if 'database' in service.configs:
                compose += f"  {service.name.lower()}_db_data:\n"
        
        # Add networks
        compose += """
networks:
  default:
    name: cloudscript_network
"""
        
        return compose
    
    def generate_requirements_txt(self, service: Service) -> str:
        """Generate requirements.txt with common dependencies"""
        requirements = [
            "fastapi==0.104.1",
            "uvicorn[standard]==0.24.0",
            "pydantic==2.5.0",
            "httpx==0.25.1"
        ]
        
        # Add database drivers if needed
        if 'database' in service.configs:
            db_type = service.configs['database'].get('type')
            if db_type == 'postgres':
                requirements.append("psycopg2-binary==2.9.9")
                requirements.append("sqlalchemy==2.0.23")
            elif db_type == 'mongodb':
                requirements.append("pymongo==4.6.0")
            elif db_type == 'redis':
                requirements.append("redis==5.0.1")
        
        # Add message queue libraries if needed
        for conn in service.connections:
            if conn.protocol == 'rabbitmq':
                requirements.append("pika==1.3.2")
            elif conn.protocol == 'kafka':
                requirements.append("kafka-python==2.0.2")
            elif conn.protocol == 'grpc':
                requirements.append("grpcio==1.59.3")
                requirements.append("grpcio-tools==1.59.3")
        
        return "\n".join(requirements) + "\n"
    
    def generate_app_py(self, service: Service) -> str:
        """Generate a basic FastAPI application"""
        port = service.configs.get('port', 8080)
        
        app_code = f'''"""
{service.name} - Auto-generated by CloudScript
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import os

app = FastAPI(title="{service.name}")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check endpoint
@app.get("/health")
async def health_check():
    return {{"status": "healthy", "service": "{service.name}"}}

'''
        
        # Generate endpoints
        for endpoint in service.endpoints:
            method = endpoint.method or "GET"
            path = endpoint.path
            response_type = endpoint.response_type or "dict"
            
            app_code += f'''
@app.{method.lower()}("{path}")
async def {self._sanitize_function_name(path)}():
    """
    {method} {path}
    Response: {response_type}
    """
    # TODO: Implement endpoint logic
    return {{"message": "Endpoint {path} called", "method": "{method}"}}
'''
        
        app_code += f'''

if __name__ == "__main__":
    uvicorn.run(
        app,
        host="0.0.0.0",
        port={port},
        log_level="info"
    )
'''
        
        return app_code
    
    def _sanitize_function_name(self, path: str) -> str:
        """Convert path to valid Python function name"""
        # Remove leading slash and convert to snake_case
        name = path.lstrip('/').replace('/', '_').replace(':', '').replace('-', '_')
        if not name:
            name = "root"
        return name


def main():
    # Test the generator
    from lexer import Lexer
    from parser import Parser
    
    code = """
    service UserService {
        endpoint /users {
            method: GET
            response: User[]
        }
        
        endpoint /users/:id {
            method: GET
            response: User
        }
        
        connect to AuthService via http
        deploy on: docker
        port: 8080
        replicas: 2
        
        database postgres {
            host: "localhost"
            port: 5432
        }
    }
    """
    
    lexer = Lexer(code)
    tokens = lexer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    
    generator = DockerGenerator()
    
    if ast.services:
        service = ast.services[0]
        print("=== Dockerfile ===")
        print(generator.generate_dockerfile(service))
        print("\n=== docker-compose.yml ===")
        print(generator.generate_docker_compose(ast))
        print("\n=== requirements.txt ===")
        print(generator.generate_requirements_txt(service))
        print("\n=== app.py ===")
        print(generator.generate_app_py(service))


if __name__ == "__main__":
    main()
